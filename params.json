{"name":"Pushqa","tagline":"An HTTP push messaging library with oData and Linq subscriptions for server side filtering of reactive events","body":"#Pushqa\r\n\r\n##Overview\r\nPushqa is a .Net library that allows the filtering of incoming push events from a server to be performed server-side.\r\n\r\nIt allows the consumer to define queries over event streams so that events that are being emitted server side can be filtered and constrained by client side code. The queries are serialized and executed server side rather than sending all the events to the client for client side filtering.\r\n\r\nPushqa uses Microsoft's Reactive Extensions (Rx) expressions over an HTTP connection with the queries serialized using the oData URI specification. The current transport pipeline supported is SignalR though more pipelines may be added in the future. By default, messages are serialized using JSON. The message service is hosted in an ASP.Net Web project running in IIS.\r\n\r\n##Get it on NuGet\r\nPushqa is now available on [Nuget](http://nuget.org/packages?q=pushqa)\r\n\r\n<iframe src=\"http://player.vimeo.com/video/40514930\" width=\"600\" height=\"420\" frameborder=\"0\" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe><p><a href=\"http://vimeo.com/40514930\">Pushqa Introduction Demo</a> from <a href=\"http://vimeo.com/user3050044\">Peter Goodman</a> on <a href=\"http://vimeo.com\">Vimeo</a>.</p>\r\n\r\n##Implementing a queryable event stream\r\nServer side implementation is easy, we only need to define our server context class with one or more event stream properties in terms of an Rx IQbservable.\r\n\r\nFirst though, lets create an ASP.Net Web Application and add the following code to the Application_Start of the Global.asax file so that incoming requests to the 'events' path of our app gets redirected to Pushqa.\r\n\r\n```c#\r\n    RouteTable.Routes.MapConnection<QueryablePushService<MyPushContext>>(\"events\", \"events\");\r\n```\r\n\r\nNow add the push context class that exposes the observable Rx event stream. \r\n\r\n```c#\r\n    public class MyPushContext {\r\n        public IQbservable<MyMessage> OneSecondTimer {\r\n            get { \r\n                return Observable.Interval(TimeSpan.FromSeconds(1))\r\n                    .Timestamp()\r\n                    .Select(i => new MyMessage {\r\n                        MessageId = i.Value, \r\n                        TimeStamp = i.Timestamp, \r\n                        Description = \"Message\"\r\n                    })\r\n                    .AsQbservable(); \r\n            }\r\n        }\r\n    }\r\n```\r\n\r\nNotice that the above Rx event stream is simply a 1 second timer projected into our custom message class. For more ways to easily create Rx event streams (e.g. from standard events) see the examples [here](http://rxwiki.wikidot.com/101samples#toc5 \"Rx 101 Samples\").\r\n\r\n##Consuming from Javascript\r\nThe above event stream will be exposed over SignalR so a javascript can use the standard SignalR API to listen to events.\r\n\r\n```html\r\n    <div>\r\n        <input type=\"button\" id=\"connect\" value=\"Connect\" />\r\n        <input type=\"button\" id=\"disconnect\" value=\"Disconnect\" />\r\n        <ul id=\"messages\"></ul>\r\n    </div>\r\n\r\n    <script src=\"~/Scripts/jquery-1.9.1.js\"></script>\r\n    <script src=\"~/Scripts/jquery-ui-1.9.2.js\"></script>\r\n    <script src=\"~/Scripts/jquery.signalR-1.0.1.js\"></script>\r\n\r\n    <script type=\"text/javascript\">\r\n        $(function () {\r\n            var connection = $.connection('../events/OneSecondTimer/', { $filter: \"(MessageId mod 2) eq 0\", $skip: 2, $top: 5 });\r\n\r\n            connection.received(function (data) {\r\n                if (data.Type == 'Completed') {\r\n                    connection.stop();\r\n                    $('#messages').append('<li>Complete</li>');\r\n                }\r\n                else {\r\n                    $('#messages').append('<li>' + JSON.stringify(data.Message) + '</li>');\r\n                }\r\n            });\r\n\r\n            connection.start();\r\n\r\n            $(\"#connect\").click(function () {\r\n                connection.start();\r\n            });\r\n\r\n            $(\"#disconnect\").click(function () {\r\n                connection.stop();\r\n            });\r\n        });\r\n    </script>\r\n```\r\n\r\nNotice that, because Pushqa uses oData's URI syntax, we can filter the event stream to every second event, we can skip the first 2 events after the subscription starts and we will only receive 5 messages.\r\n\r\nOr you can now use Reactive Extensions for Javascript which makes it much easier to respond to the different type of events.\r\n\r\n```html\r\n    <div>\r\n        <input type=\"button\" id=\"connect\" value=\"Connect\" />\r\n        <input type=\"button\" id=\"disconnect\" value=\"Disconnect\" />\r\n        <ul id=\"messages\"></ul>\r\n    </div>\r\n\r\n    <script src=\"~/Scripts/jquery-1.9.1.js\"></script>\r\n    <script src=\"~/Scripts/jquery-ui-1.9.2.js\"></script>\r\n    <script src=\"~/Scripts/jquery.signalR-1.0.1.js\"></script>\r\n    <script src=\"~/Scripts/rx.min.js\"></script>\r\n    <script src=\"~/Scripts/Rx.Pushqa.js\"></script>\r\n    <script type=\"text/javascript\">\r\n        $(function () {\r\n            var connection = $.connection('../events/OneSecondTimer/', { $filter: \"(MessageId mod 2) eq 0\", $skip: 2, $top: 5 });\r\n\r\n            // Append each message received\r\n            connection.asObservable().subscribe(\r\n                function (data) {\r\n                    // onNext\r\n                    $('#messages').append('<li>' + JSON.stringify(data) + '</li>');\r\n                },\r\n                function (error) {\r\n                    // onError\r\n                    $('#messages').append('<li>Error: ' + error + '</li>');\r\n                },\r\n                function () {\r\n                    // onCompleted\r\n                    $('#messages').append('<li>Complete</li>');\r\n                }\r\n            );\r\n\r\n            connection.start();\r\n\r\n            $(\"#connect\").click(function () {\r\n                connection.start();\r\n            });\r\n\r\n            $(\"#disconnect\").click(function () {\r\n                connection.stop();\r\n            });\r\n        });\r\n    </script>\r\n```\r\n\r\n##Consuming using the Client Linq API\r\nPushqa includes a linq provider to allow the event stream to be filtered using LINQ. Firstly we need to implement our client side EventProvider class.\r\n\r\n```c#\r\n    public class MyPushEventProvider : EventProvider {\r\n        public MyPushEventProvider() : base(new Uri(\"http://localhost/Sample.Web/events\")) { }\r\n\r\n        public EventQuerySource<MyMessage> OneSecondTimer {\r\n            get { return CreateQuery<MyMessage>(\"OneSecondTimer\"); }\r\n        }\r\n    }\r\n```\r\n\r\nThen we simply use the EventQuerySource property to construct our query and subscribe.\r\n\r\n```c#\r\n    public class MainWindowViewModel {\r\n\r\n        public MainWindowViewModel() {\r\n            // Setup the event stream subscription\r\n            MyPushEventProvider eventProvider = new MyPushEventProvider();\r\n            (from myEvent in eventProvider.OneSecondTimer\r\n             where myEvent.MessageId % 2 == 0 \r\n             select myEvent)\r\n             .Take(5)\r\n             .AsObservable()\r\n             .ObserveOnDispatcher()\r\n             .Catch<MyMessage, Exception>(e => Observable.Return(new MyMessage {Description = e.Message}))\r\n             .Subscribe(message => messages.Add(message), \r\n                () => Messages.Add(new MyMessage {Description = \"Complete\"}));\r\n\r\n        }\r\n\r\n        private readonly ObservableCollection<MyMessage> messages = new ObservableCollection<MyMessage>();\r\n\r\n        public ObservableCollection<MyMessage> Messages {\r\n            get { return messages; }\r\n        }\r\n    }\r\n```\r\n\r\nNotice how the standard LINQ query syntax works for filtering while Take and Skip are also implemented. \r\n\r\nAsObservable() created our client side observable event stream and allows us to define further Rx operators that will execute on the client. In this case we monitor the events on the WPF dispatcher, handle errors and push messages onto the Messages collection. \r\n\r\nComplete is called when the server event stream has ended e.g. when the \"Take\" count is met.\r\n\r\n&copy;Peter Goodman","google":"UA-30675784-1","note":"Don't delete this file! It's used internally to help with page regeneration."}